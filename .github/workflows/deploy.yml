name: Deploy to Server from AWS ECR

on:
  # when a new tag is pushed
  push:
    tags:
      - 'v*'
  # when the Build workflow is completed
  workflow_run:
    workflows: ['Build and Push to AWS ECR']
    types:
      - completed
    branches:
      - master
      - develop

jobs:
  deploy:
    # if the Build workflow is completed
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    environment: ${{ startsWith(github.ref, 'refs/tags/v') && !contains(github.ref, '-dev.') && 'production' || 'development' }}
    env:
      ECR_URI: ${{ secrets.ECR_URI }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_SECRET_NAME: ${{ secrets.AWS_SECRET_NAME }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Get repository name
        id: repo-name
        run: |
          REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d '/' -f 2)
          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
          echo "Repository name: $REPO_NAME"

      - name: Extract GitHub Tag
        id: tag
        run: |
          if [[ $GITHUB_EVENT_NAME == "workflow_run" ]]; then
            # Get all tags
            git fetch --tags
            # Get the latest tag
            TAG=$(git describe --tags --abbrev=0)
            echo "latest tag: $TAG"
            echo "GITHUB_TAG=$TAG" >> $GITHUB_ENV
          else
            # Get tag from the pushed tag
            echo "GITHUB_TAG=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV
          fi
          echo "Will use GitHub tag: ${{ env.GITHUB_TAG }}"
          
      - name: Create custom image tag with repo name
        run: |
          echo "IMAGE_TAG=${{ env.REPO_NAME }}.${{ env.GITHUB_TAG }}" >> $GITHUB_ENV
          echo "Will use image tag: ${{ env.IMAGE_TAG }}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Determine image tag for deployment
        id: determine-tag
        run: |
          # If the environment is production and does not contain a development marker, use the latest tag
          if [[ "${{ env.GITHUB_TAG }}" != *-dev.* && "${{ env.GITHUB_TAG }}" != *-alpha.* && "${{ env.GITHUB_TAG }}" != *-beta.* ]]; then
            DEPLOY_TAG="${{ env.REPO_NAME }}.latest"
            echo "Deploy production version, use tag: $DEPLOY_TAG"
          else
            DEPLOY_TAG="${{ env.IMAGE_TAG }}"
            echo "Deploy development version, use tag: $DEPLOY_TAG"
          fi
          echo "DEPLOY_TAG=$DEPLOY_TAG" >> $GITHUB_ENV

      - name: SSH into server and deploy
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: DEPLOY_TAG,ECR_URI,REPO_NAME,AWS_REGION,AWS_SECRET_NAME
          script: |
            echo "=== DEPLOYMENT STARTED ==="
            echo "Image: ${DEPLOY_TAG}"
            
            # Login to ECR
            echo "Logging into ECR..."
            aws ecr get-login-password --region ${AWS_REGION} | \
            docker login --username AWS --password-stdin $(echo ${ECR_URI} | cut -d/ -f1) > /dev/null 2>&1
            
            # Pull image
            echo "Pulling image..."
            docker pull ${ECR_URI}:${DEPLOY_TAG}
            
            # Create service directory
            SERVICE_DIR="$HOME/${REPO_NAME}"
            echo "Setting up service directory: ${REPO_NAME}"
            if [ ! -d "$SERVICE_DIR" ]; then
              mkdir -p "$SERVICE_DIR/backup"
              touch "$SERVICE_DIR/.env"
              echo "✓ Created new service directory"
            else
              echo "✓ Using existing service directory"
            fi
            
            # Enter the directory
            cd "$SERVICE_DIR"
            
            # Determine environment based on tag
            if [[ "${DEPLOY_TAG}" == *".latest" ]]; then
              ENV="production"
            else
              ENV="development"
            fi
            echo "Environment: ${ENV}"
            
            # Backup existing docker-compose.yml if it exists
            if [ -f "docker-compose.yml" ]; then
              cp docker-compose.yml ./backup/docker-compose.yml.bak.$(date +%Y%m%d%H%M%S)
              echo "✓ Backed up existing configuration"
            fi
            
            # Create new docker-compose.yml
            echo "Creating docker-compose configuration..."
            cat > docker-compose.yml << EOF
            services:
              app:
                image: ${ECR_URI}:${DEPLOY_TAG}
                container_name: ${REPO_NAME}
                restart: unless-stopped
                ports:
                  - "3000:3000"
                env_file:
                  - .env
                environment:
                  - DEPLOY_TAG=${DEPLOY_TAG}
                  - NODE_ENV=${ENV}
                  - AWS_SECRET_NAME=${AWS_SECRET_NAME}
                volumes:
                  - $HOME/.aws:/root/.aws
            EOF
            
            # Container management
            if docker ps -a --format '{{.Names}}' | grep -q "^${REPO_NAME}$"; then
              echo "Stopping existing container..."
              docker compose down
              echo "✓ Existing container stopped"
            else
              echo "✓ No existing container found"
            fi
            
            # Start container
            echo "Starting container..."
            docker compose up -d
            echo "✓ Container started successfully"
            
            # Clean up old images
            echo "=== STARTING IMAGE CLEANUP ==="
            
            # Set number of images to keep
            KEEP=4
            
            # Get all development version images for current service
            echo "Finding development images for ${REPO_NAME}..."
            DEV_IMAGES=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "${REPO_NAME}" | grep "\-dev\.")
            DEV_COUNT=$(echo "$DEV_IMAGES" | grep -v "^$" | wc -l)
            
            if [ $DEV_COUNT -gt $KEEP ]; then
              # Calculate how many images to delete
              TO_DELETE=$((DEV_COUNT - KEEP))
              echo "Found $DEV_COUNT development images, will delete oldest $TO_DELETE"
              
              # Get list of images to delete (sorted by version, delete oldest)
              IMAGES_TO_DELETE=$(echo "$DEV_IMAGES" | sort -V | head -n $TO_DELETE)
              
              # Delete images
              for IMAGE in $IMAGES_TO_DELETE; do
                echo "Deleting image: $IMAGE"
                docker rmi $IMAGE || echo "Warning: Could not delete $IMAGE, it may be in use"
              done
              
              echo "Deleted $TO_DELETE old images"
            else
              echo "Only $DEV_COUNT development images found, no cleanup needed"
            fi
            
            echo "=== DEPLOYMENT COMPLETED ==="