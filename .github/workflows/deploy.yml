name: Deploy to Server from AWS ECR

on:
  # when a new tag is pushed
  push:
    tags:
      - 'v*'
  # when the Build workflow is completed
  workflow_run:
    workflows: ['Build and Push to AWS ECR']
    types:
      - completed
    branches:
      - master
      - develop

jobs:
  deploy:
    # if the Build workflow is completed
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    environment: ${{ startsWith(github.ref, 'refs/tags/v') && !contains(github.ref, '-dev.') && 'production' || 'development' }}
    env:
      ECR_URI: ${{ secrets.ECR_URI }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_SECRET_NAME: ${{ secrets.AWS_SECRET_NAME }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Get repository name
        id: repo-name
        run: |
          REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d '/' -f 2)
          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
          echo "Repository name: $REPO_NAME"

      - name: Extract GitHub Tag
        id: tag
        run: |
          if [[ $GITHUB_EVENT_NAME == "workflow_run" ]]; then
            # Get all tags
            git fetch --tags
            # Get the latest tag
            TAG=$(git describe --tags --abbrev=0)
            echo "latest tag: $TAG"
            echo "GITHUB_TAG=$TAG" >> $GITHUB_ENV
          else
            # Get tag from the pushed tag
            echo "GITHUB_TAG=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV
          fi
          echo "Will use GitHub tag: ${{ env.GITHUB_TAG }}"
          
      - name: Create custom image tag with repo name
        run: |
          echo "IMAGE_TAG=${{ env.REPO_NAME }}.${{ env.GITHUB_TAG }}" >> $GITHUB_ENV
          echo "Will use image tag: ${{ env.IMAGE_TAG }}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Determine image tag for deployment
        id: determine-tag
        run: |
          # If the environment is production and does not contain a development marker, use the latest tag
          if [[ "${{ env.GITHUB_TAG }}" != *-dev.* && "${{ env.GITHUB_TAG }}" != *-alpha.* && "${{ env.GITHUB_TAG }}" != *-beta.* ]]; then
            DEPLOY_TAG="${{ env.REPO_NAME }}.latest"
            echo "Deploy production version, use tag: $DEPLOY_TAG"
          else
            DEPLOY_TAG="${{ env.IMAGE_TAG }}"
            echo "Deploy development version, use tag: $DEPLOY_TAG"
          fi
          echo "DEPLOY_TAG=$DEPLOY_TAG" >> $GITHUB_ENV

      - name: SSH into server and deploy
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: DEPLOY_TAG,ECR_URI,REPO_NAME,AWS_REGION,AWS_SECRET_NAME
          script: |
            echo "Start to deploy image: ${DEPLOY_TAG}"
            echo "ECR URI: ${ECR_URI}"
            echo "Repository name: ${REPO_NAME}"
            
            # Login to ECR
            aws ecr get-login-password --region ${AWS_REGION} | \
            docker login --username AWS --password-stdin $(echo ${ECR_URI} | cut -d/ -f1)

            # Pull image
            docker pull ${ECR_URI}:${DEPLOY_TAG}
            
            # Create service directory
            SERVICE_DIR="$HOME/${REPO_NAME}"
            echo "Service directory: $SERVICE_DIR"
            
            # Check if the repository directory exists
            if [ ! -d "$SERVICE_DIR" ]; then
              echo "Creating directory for ${REPO_NAME}..."
              mkdir -p "$SERVICE_DIR"
              mkdir -p "$SERVICE_DIR/backup"
              touch "$SERVICE_DIR/.env"
            else
              echo "Directory for ${REPO_NAME} already exists."
            fi
            
            # Enter the directory
            cd "$SERVICE_DIR"
            echo "Current directory: $(pwd)"
            
            # Determine environment based on tag
            if [[ "${DEPLOY_TAG}" == *".latest" ]]; then
              ENV="production"
            else
              ENV="development"
            fi
            
            # Backup existing docker-compose.yml if it exists
            if [ -f "docker-compose.yml" ]; then
              cp docker-compose.yml ./backup/docker-compose.yml.bak.$(date +%Y%m%d%H%M%S)
              echo "Backed up existing docker-compose.yml"
            fi
            
            # Create new docker-compose.yml
            echo "Creating new docker-compose.yml file..."
            cat > docker-compose.yml << EOF
            version: '3'
            
            services:
              app:
                image: ${ECR_URI}:${DEPLOY_TAG}
                container_name: ${REPO_NAME}
                restart: unless-stopped
                ports:
                  - "3000:3000"
                # Use env_file to load variables from .env file
                env_file:
                  - .env
                # You can also specify additional environment variables directly
                environment:
                  - DEPLOY_TAG=${DEPLOY_TAG}
                  - NODE_ENV=${ENV}
                  - AWS_SECRET_NAME=${AWS_SECRET_NAME}
                volumes:
                  - $HOME/.aws:/root/.aws
            EOF
            
            # If the container exists, stop and remove it
            if docker ps -a --format '{{.Names}}' | grep -q "^${REPO_NAME}$"; then
              echo "Container exists, stopping..."
              docker-compose down
            else
              echo "Container does not exist, will create new one"
            fi
            
            # Use Docker Compose to start the container
            echo "Starting container with Docker Compose..."
            docker-compose up -d
            
            echo "Deploy completed"
